# 원시 값과 객체의 비교

자바스크립트가 제공하는 데이터 타입은 총 7가지로 숫자, 문자, 불리언, null, undefined, symbol, 객체로 구분할 수 있다.  
그리고 위 7가지 타입은 크게 원시 타입(숫자, 문자, 불리언, null, undefined, symbol)과 객체(객체, 함수) 타입으로 구분할 수 있다.  
원시 타입과 객체 타입은 크게 **세 가지 측면에서 차이가 존재**한다.

> 1.  원시 타입의 값, 즉 **원시 값은 변경이 불가능한 값이다.** 이에 반해 **객체(참조) 타입의 값은 변경이 가능한 값**이다.
> 2.  원시 타입의 값을 변수에 할당하면, 해당 변수에는 **실제 값이 저장**된다, 반면에 객체를 변수에 저장하면, 객체가 저장된 메모리 주소 즉, **참조 값이 저장**된다.
> 3.  원시 값을 갖는 변수를 다른 변수에 할당하면, **원본 변수의 원시 값이 복사되어 전달된다. (값에 의한 전달)**, 객체 값을 갖는 변수에 다른 변수에 할당하면 **원본 객체의 참조값이 복사되어 전달된다. (참조에 의한 전달)**

## 원시 타입의 값

### 변경 불가능한 값

원시 타입의 값은 한번 생성되면 읽기 전용 값으로서 변경할 수 없다. 변수값을 재할당 한다는 것은 새로운 메모리 주소에 새로운 값을 매핑하겠다는 것을 뜻한다.  
즉, 원시 값은 변경 불가능한 값으로 어떤 일이 있어도 불변하며, 이러한 특성은 데이터의 신뢰성을 보장한다. (**불변성**)

### 값에 의한 전달

```
let answer = "string";
let new_answer = answer;

console.log(answer);     // "string"
console.log(new_answer); //"string"
```

위 처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(new_answer)에는 할당되는 변수(score)의 원시 값이 복사되어 전달되는데, 이를 **값에 의한 전달**이라고 표한한다.
answer와 new_answer는 문자 타입의 "string"을 값으로 갖지만, 둘은 다른 메모리 공간에 저장된 별개의 값이다. 결국 두 변수의 원시 값을 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

## 객체(=참조) 타입의 값

객체는 프로퍼티의 개수가 동적으로 변경되기 때문에 사전에 필요한 메모리 크기를 정해둘 수 없다.

### 변경 가능한 값

객체 타입의 값, 즉 객체는 변경이 가능한 값이다. 변수에 객체를 할당하면 변수에는 객체가 저장된 메모리 주소의 참조 값이 저장된다.

```
const person = {
    name: "성헌
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
console.log(person) // { name: "성헌" }
```

객체는 변경이 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. (추가, 삭제, 갱신) 이는 객체를 복사해서 생성하는 비용을 절약시켜 성늘을 향상시키기 위한 설계지만 이에 따른 부작용도 당연히 존재한다.

그것은 원시 값과 다르게 **여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것**이다.

### 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되는데, 이를 **참조에 의한 전달**이라 한다. (즉 두 식별자가 하나의 객체를 공유한다.)

## 얕은 복사와 깊은 복사

객체를 프로퍼티 값으로 갖는 객체(중첩 객체)의 경우 **얕은 복사는 최상위 텝스까지만 복사하는 것**을 말하고, **깊은 복사는 가장 깊은 뎁스의 객체까지 모두 복사하는 것**을 뜻한다.  
즉 얕은 복사로 생성된 객체는 최상위 뎁스의 프로퍼티는 원본과 다른 값이지만, 중첩되어 있는 객체는 참조 값으로 원본 객체의 것과 같은 값을 공유한다.  
깊은 복사는 가장 깊은 객체까지 복사하는 것이므로 원본과는 아예 다른 객체 값이다.
